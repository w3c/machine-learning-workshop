<div class="slide" role='region' aria-label="Slide 1 of 19" id="slide-1" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=1"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=1">Slide 1</a></noscript></div><div role='region'><p>Hello, everyone.</p>
<p>My name is Jason Mayes, I am the developer advocate for <a class=dfn>TensorFlow.js</a> here at Google, and today we'd like to talk to you about some of the opportunities and challenges we've seen, whilst creating and maintaining <a class=dfn>TensorFlow.js</a>, and we believe these things will be applicable to the wider Machine Learning and JavaScript community as well.</p>
<p>So let's get started.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 2 of 19" id="slide-2" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=2"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=2">Slide 2</a></noscript></div><div role='region'><p>Now, for those of you who are not aware about us, essentially <a class=dfn>TensorFlow.js</a> is an open source Machine Learning Library, that is built in JavaScript.</p>
<p>It allows you to do machine learning in the browser, on the client-side, which means you have lower latency, higher privacy, and lower serving cost of course.</p>
<p>And we also support other environments such as <a class=dfn>Node.js</a>, which means we can execute in a whole bunch of places.</p></div><div class="slide" role='region' aria-label="Slide 3 of 19" id="slide-3" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=3"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=3">Slide 3</a></noscript></div><div role='region'><p>And in fact, if we look at the next slide, you can see all the environments we run.</p>
<p>And the reason I bring this up, is because when we're defining web standards, often these things trickle into these other environments as well.</p>
<p>So, we've got all the common web browsers there, but also, <a class=dfn>Node.js</a> on the back end, React Native for mobile native apps.</p>
<p>We've got Electron for desktop native apps, and of course Raspberry Pi for Internet of Things, which we can access via <a class=dfn>Node.js</a>.</p>
<p>So, I just want to be mindful when we are thinking about ideas today that we are aware that these things could trickle through to these other areas when people try to use machine learning in JavaScript in these environments as well.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 4 of 19" id="slide-4" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=4"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=4">Slide 4</a></noscript></div><div role='region'><p>So for those of you who are not familiar with our architecture, this is the current stack.</p>
<p>Right now we have a bunch of pre-made models that sit at the very top there, that are super easy to use JavaScript classes.</p>
<p>Just below this, we have a Layers API, which is a high level API to allow you to do machine learning more easily, which is very similar to <a class=dfn>Keras</a> in Python, if you're familiar with that.</p>
<p>Below these we have our core and Ops API, which is the more mathematical layer, so allows you to do the things like linear algebra, and so on and so forth.</p>
<p>And this can talk to different environments, such as the client-side or the server-side.</p>
<p>Now if you just focus on the client-side for a second, you can see things like the browser, WeChat, React Native sitting over there, and each one of these environments understands how to talk to different back-ends, such as the CPU, <a class=dfn>WebGL</a> or web assembly.</p>
<p>Now, of course the CPU is always available, but it's the slowest form of execution.</p>
<p>If a graphics card is available, we can leverage <a class=dfn>WebGL</a> to get higher performance on the graphics card, and if web assembly is available, we can leverage high performance on the CPU, by utilizing low level instructions.</p>
<p>Now, it should also be noted people can also convert models from Python into JavaScript using our converters, as you can see on the left-hand side, and this is something to bear in mind because people might try and load larger models or more complex models in the future via this method.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 5 of 19" id="slide-5" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=5"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=5">Slide 5</a></noscript></div><div role='region'><p>Now we see three key user journeys right now, when people are using <a class=dfn>TensorFlow.js</a>.</p>
<p>First one is the ability to run models that are pre-trained, that's the easiest route and what people often start with.</p>
<p>People then choose to try and retrain their models by transfer learning as their next step to work with their own custom data, and then of course a third point is to write their own models completely from scratch.</p>
<p>And this might be in the browser entirely.</p>
<p>Or, it could be a combination of <a class=dfn>Node.js</a> and then running the resulting model in the browser.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 6 of 19" id="slide-6" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=6"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=6">Slide 6</a></noscript></div><div role='region'><p>And of course this can be used for anything you might dream up, and here's just a few examples of things people have been creating, that we've seen on the internet today.</p>
<p>Things like augmented reality, sound recognition, sentiment analysis, web page optimization, and much much more.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 7 of 19" id="slide-7" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=7"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=7">Slide 7</a></noscript></div><div role='region'><p>Well, almost anything.</p></div><div class="slide" role='region' aria-label="Slide 8 of 19" id="slide-8" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=8"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=8">Slide 8</a></noscript></div><div role='region'><p>And today, we'd like to talk to you about some of those limitations and roadblocks that we found whilst building and maintaining <a class=dfn>TensorFlow.js</a>.</p>
<p>And we believe these, will be applicable to any Machine Learning library created going forward.</p>
<p>So the first point we want to talk about is Float32.</p>
<p>Now, this is great for many of the tasks, and I know Float64 is even supported in JavaScript.</p></div><div class="slide" role='region' aria-label="Slide 9 of 19" id="slide-9" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=9"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=9">Slide 9</a></noscript></div><div role='region'><p>However, when we're doing model quantization, we actually want to support Float16, and this currently does not exist in JavaScript or in Wasm.</p>
<p>And this is really important to us, so that we can execute models faster, and use less memory when doing so too.</p>
<p>And of course, you might get a 10% drop-off in your model accuracy by doing this, but for some environments that might be acceptable, especially on mobile on older devices, where you might not have the speed to begin with.</p>
<p>Right now, on the server-side, we can actually, store things in 16-bit.</p>
<p>However, when we load it into JavaScript memory, it then gets converted to Float32, and we end up using the same memory and have the same speed as before, which means no progress there for us.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 10 of 19" id="slide-10" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=10"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=10">Slide 10</a></noscript></div><div role='region'><p>So, what if we could support model quantization to use less memory and gain faster inference speeds in JavaScript at runtime.</p>
<p>This is the question we'd like to pose to you today.</p>
<p>Now, of course, to address this, we'd need to do this in both JavaScript and web assembly, so that supports all the environments we will execute in the foreseeable future, as we showed at the beginning of this presentation.</p></div><div class="slide" role='region' aria-label="Slide 11 of 19" id="slide-11" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=11"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=11">Slide 11</a></noscript></div><div role='region'><p>Next up, garbage collection.</p>
<p>For <a class=dfn>WebGL</a>. As you know, JavaScript is really great at cleaning up after itself when writing Vanilla JavaScript code.</p>
<p>However, the same is not so true for <a class=dfn>WebGL</a>.</p>
<p>And, as you know, <a class=dfn>TensorFlow.js</a> uses <a class=dfn>WebGL</a> to get graphics card acceleration for our Machine Learning models in the web browser and beyond.</p>
<p>So, right now we have a function called TF.tidy() that we've created to clean up after ourselves if the user puts their code within this function.</p>
<p>However, not all users know about this at the very beginning especially beginners, and for that reason, it'd be really nice to have the same level of clean-up with graphics card memory as we do with the regular JavaScript code.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 12 of 19" id="slide-12" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=12"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=12">Slide 12</a></noscript></div><div role='region'><p>So the question is here, how can we clean up <a class=dfn>WebGL</a> memory as well?</p>
<p>So we know that <a class=dfn>WebGPU</a> is also coming down the line, but maybe this needs to be addressed in that specification as well.</p>
<p>Can we clean up graphics card memory both in <a class=dfn>WebGPU</a> and <a class=dfn>WebGL</a>.</p>
<p>And the latter, this also might benefit people working with 3D graphics and other things too beyond even the Machine Learning space.</p></div><div class="slide" role='region' aria-label="Slide 13 of 19" id="slide-13" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=13"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=13">Slide 13</a></noscript></div><div role='region'><p>Next up, graphics card acceleration.</p>
<p>Currently, we have <a class=dfn>WebGL</a> to execute Ops in the machine learning model as we previously discussed, but it'd be much more efficient if the browser exposed lower level APIs to the graphics card so we could more efficiently leverage the hardware.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 14 of 19" id="slide-14" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=14"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=14">Slide 14</a></noscript></div><div role='region'><p>Now, the question here is what lower level support do we need for efficient Machine Learning when using the graphics card.</p>
<p>And of course, <a class=dfn>WebGPU</a> is on the way, but, what else needs to be added to that spec to ensure we have something that works well, specifically for machine learning.</p></div><div class="slide" role='region' aria-label="Slide 15 of 19" id="slide-15" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=15"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=15">Slide 15</a></noscript></div><div role='region'><p>Next up, we've got Model Security.</p>
<p>Now we see a lot of production use cases, whereby they require the model to be securely delivered to the client, in a way that it can't be copied and used on other websites.</p>
<p>Especially for large corporate brands, they spend a lot of money and time creating these models, and where they won't just give away their IP for free.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 16 of 19" id="slide-16" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=16"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=16">Slide 16</a></noscript></div><div role='region'><p>So, our question is here, how can we deliver a Machine Learning model to the JavaScript environment in the Web browser, without revealing it, maybe there's a way that we can have a secure way to grab some arbitrary JavaScript code from the server, that is doing Machine Learning stuff along with the model as well and the assets you might need to execute, and all that can be downloaded by the browser behind the scenes, in private memory, which cannot be accessed by the JS developer on the front end.</p>
<p>However, they can do some kind of remote procedure call to that code, so that they can execute it and get results back, without exposing the model itself.</p>
<p>And this is up to discussion of course, that's just one example of how it could be solved which would require browser level implementation support to do that properly.</p>
<p>And currently, this is a big barrier for many people trying to go into production-use cases but still want the benefits of running on the client side, such as privacy and lower latency and cost savings on the server.</p>
<p>And of course, as soon as you put the model on the server-side, those benefits disappear because you have to then send the data from the client to the server.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 17 of 19" id="slide-17" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=17"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=17">Slide 17</a></noscript></div><div role='region'><p>And what about model warm-up, it can take a couple of uses before the model can actually run at the optimal speed in the browser environment.</p>
<p>Of course, first of all you need to download the model.</p>
<p>Secondly you need to load it into memory and pass all that stuff, and then thirdly, you need to just run some data for at once to get everything else set up.</p>
<p>And this can take a non trivial amount of time especially for larger models.</p>
<p></p></div><div class="slide" role='region' aria-label="Slide 18 of 19" id="slide-18" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=18"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=18">Slide 18</a></noscript></div><div role='region'><p>So the question here becomes, what if there is a standardized way to specify that a better model is available and should be prepared and swapped to when ready kinda like progressive enhancement.</p>
<p>Now taking a very hypothetical example, maybe you've got an object recognition model, and this could be something like COCO SSD that gives you the bounding box data.</p>
<p>This loads really fast in the web browser right now and can be used very quickly and efficiently.</p>
<p>But maybe your end goal is to actually have some kind of image segmentation model which might be heavier to load.</p>
<p>So what if you could take that initial smaller model, load that, get some results coming in straight away, but once heavier model is actually ready, you can switch to that automatically.</p>
<p>And this could be very interesting as things progress and we start seeing larger models being used in the web environment in many years to come.</p></div><div class="slide" role='region' aria-label="Slide 19 of 19" id="slide-19" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=19"><noscript><a href="https://www.w3.org/2020/Talks/mlws/jm_tensorflowjs.pdf#page=19">Slide 19</a></noscript></div><div role='region'><p>And with that, thanks for watching and I encourage people to check out the #MadeWithTFJS hashtag on Twitter or LinkedIn to see what our community has been making.</p>
<p>You can see a whole bunch of awesome stuff that our community has made, which might inspire you as well of other questions for this discussion.</p>
<p>People are really pushing the boundaries by combining <a class=dfn>TensorFlow.js</a> with things like <a class=dfn>WebGL</a>, <a class=dfn>WebRTC</a>, <a class=dfn>WebXR</a>, all these other web standards are combining with Machine Learning to do many many great things.</p>
<p>So, feel free to check that out, and we'd love to talk to you later on for the full discussion about this topic.</p>
<p>Thank you very much for watching.</p></div>