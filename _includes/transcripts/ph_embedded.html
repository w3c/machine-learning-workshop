<div class="slide" role='region' aria-label="Slide 1 of 11" id="slide-1" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=1"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=1">Slide 1</a></noscript></div><div role='region'><p>Hello, my name is Peter Hoddie.</p></div><div class="slide" role='region' aria-label="Slide 2 of 11" id="slide-2" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=2"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=2">Slide 2</a></noscript></div><div role='region'><p>I'm not here to talk about Machine Learning.</p>
<p>I don't know much about it.</p>
<p>I'm certainly not an expert.</p>
<p>I am here to talk about JavaScript, specifically JavaScript beyond the web platform.</p>
<p>I have some experience there, having delivered my first embedded consumer product powered by JavaScript over a dozen years ago.</p>
<p>I am co-founder of Moddable Tech, creators of XS, the only modern JavaScript engine for resource constrained devices.</p>
<p>I am also chair of Ecma TC53, the ECMAScript Modules for Embedded Systems standards committee.</p>
<p>TC53 is defining standard JavaScript APIs for low level device operations -- digital, serial, network sockets.</p>
<p>From there, we are building up to sensors, displays, and more.</p>
<p>Our work allows devices to boot to JavaScript, putting scripts in complete control of the device.</p></div><div class="slide" role='region' aria-label="Slide 3 of 11" id="slide-3" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=3"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=3">Slide 3</a></noscript></div><div role='region'><p>This workshop is about Machine Learning APIs in JavaScript in the browser.</p>
<p>I'm here to explore how it might be extended to low cost, resource constrained embedded devices.</p>
<p>That would be a big win because the web is just part of the world of digital devices.</p>
<p>If developers could share their Machine Learning knowledge, experience, and even code across more devices, that can only accelerate availability of products that benefit users.</p></div><div class="slide" role='region' aria-label="Slide 4 of 11" id="slide-4" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=4"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=4">Slide 4</a></noscript></div><div role='region'><p>Before going further I should explain what I mean by a low cost, resource constrained embedded device.</p>
<p>You might have in mind a Raspberry Pi, an inexpensive Linux computer used in some embedded systems.</p>
<p>I have something much more constrained in mind, something that can't run Linux or Node.</p>
<p>My favorite example is the ESP8266 from Espressif, a $1 module that includes a CPU, some RAM, Wi-Fi, and flash storage.</p>
<p>Moddable runs modern JavaScript -- the ECMAScript 2020 standard -- on these.</p>
<p>For about another dollar, you can get the ESP32 with 4 times more memory, two CPU cores that run three times as fast, and Bluetooth LE. While these devices may not be capable of much Machine Learning, take a look at their big brother.</p>
<p>The i.MX 8M Plus from NXP has a hardware Neural Processing Unit (NPU) that runs up to 2.25 TOPS.</p>
<p>The goal is to move more Machine Learning processing to the edge.</p>
<p>While the i.MX 8M Plus is a relatively high-end embedded processor, NXP has stated their intention to bring similar capabilities to lower cost components.</p>
<p>Other silicon manufacturers are adding hardware acceleration for Machine Learning to their product lines.</p>
<p>We can safely assume there will be Machine Learning hardware accelerators in the embedded silicon that powers IoT products.</p></div><div class="slide" role='region' aria-label="Slide 5 of 11" id="slide-5" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=5"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=5">Slide 5</a></noscript></div><div role='region'><p>But, what APIs will developers use to access it?</p>
<p>If history is any guide, each silicon manufacturer will have their own API.</p>
<p>Determined developers will use these vendor-specific native APIs directly, sacrificing portability.</p>
<p>Some de-facto APIs may emerge, perhaps commercially or through open source, that some silicon manufacturers will grudgingly support.</p>
<p>What about JavaScript?</p>
<p>While these devices can run JavaScript, they often cannot run the JavaScript APIs used on the web because these devices typically have around 1% of the memory and CPU power of a web host.</p>
<p>Web APIs are designed to be powerful, complete, and convenient.</p>
<p>That's great for computer and mobile, but doesn't migrate to embedded.</p></div><div class="slide" role='region' aria-label="Slide 6 of 11" id="slide-6" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=6"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=6">Slide 6</a></noscript></div><div role='region'><p>Two patterns and one anti-pattern have emerged from my work with JavaScript on embedded systems that may be relevant for bridging Machine Learning JavaScript APIs between the web and embedded systems.</p></div><div class="slide" role='region' aria-label="Slide 7 of 11" id="slide-7" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=7"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=7">Slide 7</a></noscript></div><div role='region'><p>In some cases, it is practical to use the same JavaScript API on both web and embedded devices.</p>
<p>The W3C Sensor APIs are a good example.</p>
<p>They give access to sensors in a phone such as the accelerometer and light meter.</p>
<p>The APIs are very simple, making it practical to implement them on resource constrained embedded systems.</p>
<p>In fact, for embedded system uses it turns out the W3C Sensor APIs are too simple.</p>
<p>They do not provide the ability to configure the sensors, manage energy use, or access manufacturer specific capabilities that many embedded products require.</p>
<p>So, TC53 designed a lower level sensor driver that provides all the needed features.</p>
<p>We intentionally designed the TC53 sensor driver so it would be straightforward to implement the W3C Sensor API using TC53 sensor drivers.</p>
<p>For example, no mapping of sensor data value is required -- the TC53 sensor drivers normatively adopt the W3C Sensor values.</p></div><div class="slide" role='region' aria-label="Slide 8 of 11" id="slide-8" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=8"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=8">Slide 8</a></noscript></div><div role='region'><p>In other cases, the JavaScript API from the web is impractical on an embedded device.</p>
<p>The Serial API in Chrome is a good example.</p>
<p>Nearly every embedded device has a serial connection and there's nothing fundamentally different about a serial between a computer and an embedded device.</p>
<p>Unfortunately, because Chrome's Serial API is designed to be convenient to use on the web platform, it makes extensive use of asynchronous promises and powerful (but heavy) streams.</p>
<p>TC53's Serial API provides similar capabilities through a much smaller and lighter API.</p>
<p>To avoid unnecessary differences, TC53 adopted the naming conventions of Chrome where practical.</p>
<p>What's particularly interesting is that we found it found was possible to implement the TC53 Serial API using the Chrome Serial API -- effectively emulating the embedded JavaScript API in the browser.</p>
<p>This might feel a bit upside-down, but it provides a single Serial API for both the web and embedded devices, allowing increased code sharing.</p></div><div class="slide" role='region' aria-label="Slide 9 of 11" id="slide-9" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=9"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=9">Slide 9</a></noscript></div><div role='region'><p>One word of warning.</p>
<p>I would caution against the anti-pattern of creating a light" version of any web API to use on embedded. Light" versions are subsets of a full API.</p>
<p>They are almost always painful to use for a couple reasons.</p>
<p>First, developers expect the full API, and are annoyed as they discover the differences.</p>
<p>Second, because the Light" API looks about the same, developers try to use it to perform the same operations as the full API, but on less powerful devices. The results are always disappointing. It is better to have a dedicated embedded API and a dedicated web API that share concepts and operations to the extent practical. That gives authors of libraries and framework a foundation to build APIs that support both for specific domains or to emulate the embedded API on the web, as we've done with Serial. To close, I hope this W3C initiative will consider including low-cost, resource constrained devices in its scope of work in some way. My impression is that it may be feasible. If achieved, I have no doubt that it would be valuable to the overall eco-system by expanding the availability of well designed APIs for working with Machine Learning computing resources. Thank you to the W3C for this opportunity to share my experience and perspective.</p></div><div class="slide" role='region' aria-label="Slide 10 of 11" id="slide-10" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=10"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=10">Slide 10</a></noscript></div><div role='region'><p></p></div><div class="slide" role='region' aria-label="Slide 11 of 11" id="slide-11" data-fmt="pdf" data-src="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=11"><noscript><a href="https://www.w3.org/2020/Talks/mlws/ph_embedded.pdf#page=11">Slide 11</a></noscript></div><div role='region'><p></p></div>